<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arcade Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #202028;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* --- UI Screens --- */
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(32, 32, 40, 0.95);
            color: white;
            z-index: 20;
            text-align: center;
            transition: opacity 0.3s;
            font-family: 'Press Start 2P', cursive; 
        }

        h1 {
            font-size: 2.2rem;
            color: #f39c12;
            text-shadow: 4px 4px 0 #c0392b;
            margin-bottom: 25px;
            line-height: 1.6;
        }

        h2 { font-size: 1.2rem; color: #3498db; margin-bottom: 15px; }

        /* --- Buttons --- */
        button {
            background: #2980b9;
            border: 4px solid #fff;
            color: #fff;
            padding: 15px 20px;
            font-size: 0.9rem;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            box-shadow: 0 6px 0 #111;
            margin-top: 10px;
            text-transform: uppercase;
            position: relative;
            min-width: 180px;
        }

        button:active { transform: translateY(6px); box-shadow: 0 0 0; }
        
        .menu-btns { display: flex; flex-direction: column; gap: 12px; }

        /* --- Shop UI --- */
        #shop-container { display: flex; gap: 15px; margin-bottom: 20px; }
        .shop-card {
            border: 4px solid #fff; background: #2c3e50; padding: 10px; width: 130px;
            display: flex; flex-direction: column; align-items: center; cursor: pointer;
        }
        .shop-card.owned { border-color: #2ecc71; background: #27ae60; }
        .shop-card:active { transform: scale(0.95); }
        .pixel-icon {
            width: 40px; height: 40px; background: #000; border: 2px solid #fff; margin-bottom: 8px;
            display: flex; align-items: center; justify-content: center; font-size: 18px; color: #f1c40f;
        }
        .price-tag { font-size: 0.6rem; margin-top: 5px; color: #f1c40f; }
        .shop-card.owned .price-tag { display: none; }

        /* --- Settings UI --- */
        .setting-row {
            display: flex; justify-content: space-between; align-items: center;
            width: 350px; margin-bottom: 15px; font-size: 0.7rem;
            font-family: 'Press Start 2P', cursive;
        }
        .key-btn {
            background: #34495e; border: 2px solid #95a5a6; 
            padding: 8px; width: auto; min-width: 80px; 
            font-size: 0.5rem; box-shadow: none; margin: 0;
            font-family: 'Press Start 2P', cursive;
        }
        .key-btn.listening { background: #e74c3c; border-color: #c0392b; animation: pulse 0.5s infinite; }
        
        /* Slider Styling */
        input[type=range] {
            -webkit-appearance: none; width: 120px; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 20px; width: 20px;
            background: #f1c40f; border: 2px solid #fff; cursor: pointer; margin-top: -8px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #fff;
        }

        /* --- History UI --- */
        .history-box {
            width: 90%;
            background: rgba(0,0,0,0.4); 
            border: 3px solid #555; 
            padding: 15px; 
            margin-bottom: 15px;
            font-size: 0.6rem;
        }
        
        .history-header {
            display: flex;
            justify-content: space-between;
            color: #f1c40f;
            border-bottom: 2px solid #fff;
            padding-bottom: 8px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .history-row { 
            display: flex; 
            justify-content: space-between; 
            padding: 8px 0;
            border-bottom: 1px dashed #555;
            color: #bdc3c7;
        }
        
        .col { width: 33%; text-align: center; }
        .col-left { text-align: left; }
        .col-right { text-align: right; }

        /* Jump buttons */
        .jump-container { display: flex; gap: 5px; }
        .jump-btn-small { min-width: 50px; padding: 5px; font-size: 0.4rem; }

        @keyframes pulse { 0% {opacity:1;} 50% {opacity:0.7;} 100% {opacity:1;} }

        /* --- HUD --- */
        #hud {
            position: absolute; top: 20px; left: 20px; color: white;
            font-size: 0.9rem; text-shadow: 2px 2px 0 #000; z-index: 15; display: none; line-height: 1.8; pointer-events: none;
        }

        #pause-btn {
            position: absolute; top: 20px; right: 20px; 
            color: white; font-size: 1.2rem; cursor: pointer; 
            z-index: 25; display: none; 
            text-shadow: 2px 2px 0 #000;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border: 2px solid #fff;
        }
        #pause-btn:active { transform: scale(0.9); }

        /* --- Mobile Controls --- */
        #mobile-controls {
            display: none; position: absolute; bottom: 10px; width: 100%; height: 180px; z-index: 15; pointer-events: none;
        }
        .ctrl-btn {
            position: absolute; width: 95px; height: 95px;
            background: rgba(255,255,255,0.15); border: 4px solid rgba(255,255,255,0.4);
            pointer-events: auto; display: flex; align-items: center; justify-content: center;
            font-size: 40px; color: white; border-radius: 15px; backdrop-filter: blur(2px);
        }
        .ctrl-btn:active { background: rgba(255,255,255,0.3); border-color: #fff; transform: scale(0.95); }
        #btn-left { left: 20px; bottom: 30px; }
        #btn-right { left: 130px; bottom: 30px; }
        #btn-jump { right: 20px; bottom: 50px; width: 110px; height: 110px; background: rgba(46, 204, 113, 0.3); font-size: 50px; }
        #btn-hook { right: 150px; bottom: 30px; background: rgba(231, 76, 60, 0.3); font-size: 32px; }

    </style>
</head>
<body>

    <audio id="sfx-start" src="start.mp3"></audio>
    <audio id="sfx-die" src="die.mp3"></audio>
    <audio id="sfx-jump" src="jump.mp3"></audio>
    <audio id="sfx-hook" src="hook.mp3"></audio>
    <audio id="sfx-coin" src="coin.mp3"></audio>
    <audio id="bg-music" src="music.mp3" loop></audio>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="main-menu" class="screen">
            <h1>ARCADE<br>ADVENTURE</h1>
            <div class="menu-btns">
                <button onclick="ensureAudio(); startGame()">PLAY GAME</button>
                <button onclick="ensureAudio(); openShop()">SHOP</button>
                <button onclick="ensureAudio(); openSettings()">SETTINGS</button>
                <button onclick="ensureAudio(); openHistory()">HISTORY</button>
            </div>
            <div style="margin-top:20px; font-size:0.6rem; color:#bdc3c7; line-height: 1.8;">
                BEST: <span id="menu-best">0</span>m | TIME: <span id="menu-best-time">0:00</span><br>
                COINS: <span id="menu-total-coins" style="color:#f1c40f">0</span>
            </div>
        </div>

        <div id="history-screen" class="screen" style="display: none;">
            <h1>GAME HISTORY</h1>
            <div style="width: 90%; margin-bottom: 5px; color: #3498db; font-size: 0.7rem; text-align: left;">LAST RUN:</div>
            <div class="history-box" id="last-run-display">
                <div style="text-align:center; color:#7f8c8d;">NO DATA YET</div>
            </div>
            <div style="width: 90%; margin-bottom: 5px; color: #f1c40f; font-size: 0.7rem; text-align: left;">TOP 5 RUNS:</div>
            <div class="history-box">
                <div class="history-header">
                    <span class="col col-left">DIST</span>
                    <span class="col">TIME</span>
                    <span class="col col-right">COIN</span>
                </div>
                <div id="top-runs-list"></div>
            </div>
            <button onclick="playSound('jump'); closeHistory()" style="background:#c0392b;">BACK</button>
        </div>

        <div id="shop-screen" class="screen" style="display: none;">
            <h1 style="font-size:1.5rem;">SHOP</h1>
            <div style="color:#f1c40f; margin-bottom:20px;">COINS: <span id="shop-coins">0</span></div>
            <div id="shop-container">
                <div class="shop-card" id="card-jump" onclick="buyAbility('doubleJump', 50)">
                    <div class="pixel-icon">J¬≤</div>
                    <div style="font-size:0.5rem;">DOUBLE JUMP</div>
                    <div class="price-tag">50 C</div>
                </div>
                <div class="shop-card" id="card-dash" onclick="buyAbility('dash', 100)">
                    <div class="pixel-icon">>></div>
                    <div style="font-size:0.5rem;">SPEED DASH</div>
                    <div class="price-tag">100 C</div>
                </div>
            </div>
            <button onclick="playSound('jump'); closeShop()" style="background:#c0392b;">BACK</button>
        </div>

        <div id="settings-screen" class="screen" style="display: none;">
            <h1 style="font-size:1.5rem; margin-bottom:20px;">SETTINGS</h1>
            <div class="setting-row">
                <span>VIBRATION</span>
                <button id="btn-vib" onclick="playSound('jump'); toggleVib()" class="key-btn" style="width:60px">ON</button>
            </div>
            <div class="setting-row">
                <span>GRAPHICS: <span id="perf-label" style="color:#f1c40f">HIGH</span></span>
                <input type="range" id="perf-slider" min="0" max="2" step="1" oninput="updatePerfSetting(this.value)" onchange="savePerfSetting()">
            </div>
            <div style="margin: 15px 0; border-top: 2px solid #555; width: 80%;"></div>
            <p style="font-size:0.6rem; margin-bottom:15px; color:#f1c40f;">CONTROLS</p>
            <div class="setting-row">
                <span>LEFT</span> <button id="bind-left" onclick="playSound('jump'); rebindKey('left')" class="key-btn">ArrowLeft</button>
            </div>
            <div class="setting-row">
                <span>RIGHT</span> <button id="bind-right" onclick="playSound('jump'); rebindKey('right')" class="key-btn">ArrowRight</button>
            </div>
            <div class="setting-row">
                <span>JUMP (3 KEYS)</span>
                <div class="jump-container">
                    <button id="bind-jump-0" onclick="playSound('jump'); rebindJump(0)" class="key-btn jump-btn-small">Space</button>
                    <button id="bind-jump-1" onclick="playSound('jump'); rebindJump(1)" class="key-btn jump-btn-small">Up</button>
                    <button id="bind-jump-2" onclick="playSound('jump'); rebindJump(2)" class="key-btn jump-btn-small">W</button>
                </div>
            </div>
            <div class="setting-row">
                <span>HOOK</span> <button id="bind-hook" onclick="playSound('jump'); rebindKey('hook')" class="key-btn">KeyZ</button>
            </div>
            <button onclick="playSound('jump'); closeSettings()" style="background:#c0392b; margin-top:20px;">BACK</button>
        </div>

        <div id="pause-menu" class="screen" style="display: none; background: rgba(0,0,0,0.8);">
            <h1 style="font-size: 2rem;">PAUSED</h1>
            <button onclick="playSound('jump'); resumeGame()">RESUME</button>
            <button onclick="playSound('jump'); quitToMenu()" style="background:#c0392b;">MAIN MENU</button>
        </div>

        <div id="game-over" class="screen" style="display: none;">
            <h1 style="color: #e74c3c;">GAME OVER</h1>
            <p style="font-size: 1rem;">DISTANCE: <span id="final-score">0</span>m</p>
            <p style="font-size: 0.8rem; color:#f1c40f; margin-bottom:15px;">+<span id="final-coins">0</span> COINS</p>
            <button id="btn-revive" onclick="playSound('jump'); revivePlayer()" style="background:#27ae60; border-color:#2ecc71; margin-bottom:10px;">
                REVIVE (<span id="revive-cost">10</span> C)
            </button>
            <button onclick="playSound('jump'); resetGame()">RETRY</button>
            <button onclick="playSound('jump'); location.reload()" style="background:#7f8c8d; font-size:0.8rem;">MENU</button>
        </div>

        <div id="pause-btn" onclick="playSound('jump'); pauseGame()">||</div>
        <div id="hud">
            DIST: <span id="score">0</span>m<br>
            TIME: <span id="time-display" style="color:#3498db">00:00</span><br>
            <span style="color:#f1c40f">COINS: <span id="coin-count">0</span></span>
            <div id="powerup-status" style="margin-top:5px; font-size:0.6rem;"></div>
        </div>
        
        <div id="mobile-controls">
            <div class="ctrl-btn" id="btn-left">‚¨Ö</div>
            <div class="ctrl-btn" id="btn-right">‚û°</div>
            <div class="ctrl-btn" id="btn-hook">üï∏Ô∏è</div>
            <div class="ctrl-btn" id="btn-jump">‚¨Ü</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- ASSETS ---
        const assets = { 
            player: new Image(), ground: new Image(), bg: new Image(), bgLow: new Image(),
            coin: new Image(), spike: new Image(), enemy: new Image(),
            magnet: new Image(), shield: new Image(), star: new Image()
        };
        assets.player.src = 'player.png';
        assets.ground.src = 'ground.png';
        assets.bg.src = 'bg.png';
        assets.bgLow.src = 'bg (0).png'; 
        assets.coin.src = 'coin.png';
        assets.spike.src = 'spike.png';
        assets.enemy.src = 'enemy.png';
        assets.magnet.src = 'magnet.png';
        assets.shield.src = 'shield.png';
        assets.star.src = 'star.png';

        const audio = {
            start: document.getElementById('sfx-start'),
            die: document.getElementById('sfx-die'),
            jump: document.getElementById('sfx-jump'),
            hook: document.getElementById('sfx-hook'),
            coin: document.getElementById('sfx-coin'),
            music: document.getElementById('bg-music')
        };

        let audioEnabled = false;
        function ensureAudio() {
            if(!audioEnabled) {
                playSound('jump'); 
                audioEnabled = true;
            }
        }

        function playSound(name) {
            const s = audio[name];
            if(s) {
                if(name === 'music') { 
                    s.currentTime = 0; s.volume = 0.4; 
                    const p = s.play();
                    if (p !== undefined) { p.catch(() => {}); }
                }
                else if (name === 'start') {
                    s.currentTime = 0; s.volume = 0.7; s.play().catch(()=>{});
                }
                else { 
                    const c = s.cloneNode(); c.volume = 0.6; 
                    c.play().catch(()=>{}); 
                }
            }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        const SAVE_KEY = 'ArcadeAdv_Data_FinalV6_Fix';
        
        let savedData = { 
            highScore: 0, totalCoins: 0, bestTime: 0,
            hasDoubleJump: false, hasDash: false,
            history: [], lastRun: null, 
            settings: { 
                vib: true, perf: 2, 
                keys: { left:'ArrowLeft', right:'ArrowRight', jump: ['Space', 'ArrowUp', 'KeyW'], hook:'KeyZ' } 
            }
        };

        function loadData() {
            const d = localStorage.getItem(SAVE_KEY);
            if(d) {
                const loaded = JSON.parse(d);
                savedData = { ...savedData, ...loaded };
                if(typeof savedData.settings.perf === 'boolean') savedData.settings.perf = savedData.settings.perf ? 1 : 2;
                if(!savedData.history) savedData.history = [];
            }
            updateUI(); updateSettingsUI();
        }

        function saveDataToStorage() {
            localStorage.setItem(SAVE_KEY, JSON.stringify(savedData));
            updateUI();
        }

        function updateUI() {
            document.getElementById('menu-best').innerText = savedData.highScore;
            document.getElementById('menu-best-time').innerText = formatTime(savedData.bestTime);
            document.getElementById('menu-total-coins').innerText = savedData.totalCoins;
            document.getElementById('shop-coins').innerText = savedData.totalCoins;
            const jumpCard = document.getElementById('card-jump');
            const dashCard = document.getElementById('card-dash');
            if(savedData.hasDoubleJump) jumpCard.classList.add('owned'); else jumpCard.classList.remove('owned');
            if(savedData.hasDash) dashCard.classList.add('owned'); else dashCard.classList.remove('owned');
        }

        // --- MENUS ---
        function openShop() { document.getElementById('main-menu').style.display = 'none'; document.getElementById('shop-screen').style.display = 'flex'; updateUI(); }
        function closeShop() { document.getElementById('shop-screen').style.display = 'none'; document.getElementById('main-menu').style.display = 'flex'; }
        
        function openSettings() { document.getElementById('main-menu').style.display = 'none'; document.getElementById('settings-screen').style.display = 'flex'; updateSettingsUI(); }
        function closeSettings() { document.getElementById('settings-screen').style.display = 'none'; document.getElementById('main-menu').style.display = 'flex'; }

        function openHistory() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('history-screen').style.display = 'flex';
            const lastBox = document.getElementById('last-run-display');
            if(savedData.lastRun) {
                lastBox.innerHTML = `
                    <div class="history-row">
                        <span class="col col-left" style="color:#fff">SCORE</span>
                        <span class="col" style="color:#3498db">TIME</span>
                        <span class="col col-right" style="color:#f1c40f">COINS</span>
                    </div>
                    <div class="history-row" style="border:none">
                        <span class="col col-left">${savedData.lastRun.score}m</span>
                        <span class="col">${formatTime(savedData.lastRun.time)}</span>
                        <span class="col col-right">${savedData.lastRun.coins}</span>
                    </div>
                `;
            } else {
                lastBox.innerHTML = `<div style="text-align:center; color:#7f8c8d; padding:10px;">NO RUNS YET</div>`;
            }
            const topList = document.getElementById('top-runs-list');
            topList.innerHTML = '';
            if(savedData.history.length === 0) {
                topList.innerHTML = '<div style="text-align:center; padding:10px; color:#7f8c8d;">EMPTY</div>';
            } else {
                savedData.history.forEach((run) => {
                    topList.innerHTML += `
                    <div class="history-row">
                        <span class="col col-left">${run.score}m</span>
                        <span class="col" style="color:#3498db">${formatTime(run.time)}</span>
                        <span class="col col-right" style="color:#f1c40f;">${run.coins}</span>
                    </div>`;
                });
            }
        }
        function closeHistory() {
            document.getElementById('history-screen').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
        }

        function buyAbility(ability, price) {
            if((ability === 'doubleJump' && savedData.hasDoubleJump) || (ability === 'dash' && savedData.hasDash)) return;
            if(savedData.totalCoins >= price) {
                savedData.totalCoins -= price;
                if(ability === 'doubleJump') savedData.hasDoubleJump = true;
                if(ability === 'dash') savedData.hasDash = true;
                playSound('coin'); saveDataToStorage();
            } else alert("NOT ENOUGH COINS!");
        }

        function updateSettingsUI() {
            document.getElementById('btn-vib').innerText = savedData.settings.vib ? "ON" : "OFF";
            const slider = document.getElementById('perf-slider');
            const label = document.getElementById('perf-label');
            slider.value = savedData.settings.perf;
            const txt = ["LOW", "MED", "HIGH"];
            const cols = ["#e74c3c", "#f39c12", "#2ecc71"];
            label.innerText = txt[savedData.settings.perf];
            label.style.color = cols[savedData.settings.perf];
            document.getElementById('bind-left').innerText = savedData.settings.keys.left;
            document.getElementById('bind-right').innerText = savedData.settings.keys.right;
            document.getElementById('bind-hook').innerText = savedData.settings.keys.hook;
            document.getElementById('bind-jump-0').innerText = savedData.settings.keys.jump[0];
            document.getElementById('bind-jump-1').innerText = savedData.settings.keys.jump[1] || '---';
            document.getElementById('bind-jump-2').innerText = savedData.settings.keys.jump[2] || '---';
        }

        function toggleVib() {
            savedData.settings.vib = !savedData.settings.vib;
            saveDataToStorage(); updateSettingsUI();
        }

        function updatePerfSetting(val) {
            savedData.settings.perf = parseInt(val);
            updateSettingsUI();
        }
        function savePerfSetting() {
            saveDataToStorage();
            if(!isRunning) draw(); 
        }

        function rebindKey(action) {
            const btn = document.getElementById('bind-' + action);
            btn.innerText = "..."; btn.classList.add('listening');
            const handler = (e) => {
                e.preventDefault(); savedData.settings.keys[action] = e.code;
                btn.classList.remove('listening'); saveDataToStorage(); updateSettingsUI();
                window.removeEventListener('keydown', handler);
            };
            window.addEventListener('keydown', handler);
        }
        function rebindJump(index) {
            const btn = document.getElementById('bind-jump-' + index);
            btn.innerText = "..."; btn.classList.add('listening');
            const handler = (e) => {
                e.preventDefault(); savedData.settings.keys.jump[index] = e.code;
                btn.classList.remove('listening'); saveDataToStorage(); updateSettingsUI();
                window.removeEventListener('keydown', handler);
            };
            window.addEventListener('keydown', handler);
        }

        // --- GAME VARIABLES ---
        let width, height;
        const GRAVITY = 0.6; const FRICTION = 0.85;
        const MOVE_SPEED = 1.0; const JUMP_FORCE = -15;
        const HOOK_SPEED = 32; const HOOK_PULL = 1.9; const DASH_FORCE = 25; 
        const ENEMY_SPEED_PATROL = 2; const ENEMY_SPEED_CHASE = 4.5; const ENEMY_VISION = 500;
        
        let camera = { x: 0 };
        let score = 0; let collectedCoins = 0;
        let isRunning = false; let isPaused = false;
        let gameTick = 0; let startTime = 0; let elapsedTime = 0;

        let reviveCost = 10; let revivesUsed = 0;
        let normalCoinsSpawned = 0; let coinsToNextMega = 10;

        const player = {
            x: 100, y: 200, w: 80, h: 80, 
            vx: 0, vy: 0, grounded: false, facingRight: true, jumpCount: 0, 
            hook: { state: 'idle', x: 0, y: 0, vx: 0, vy: 0, targetX: 0, targetY: 0 }
        };

        // --- POWERUP SYSTEM ---
        let powerupItems = [];
        const activeEffects = {
            magnet: 0,  
            shield: false,
            doubleScore: 0,
            reviveShieldTimer: 0 // New timer for revive invincibility
        };

        let lastTapKey = null; let lastTapTime = 0;
        let platforms = []; let coins = []; let traps = []; let enemies = []; 
        let currentTarget = null;
        const keys = { left: false, right: false };

        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
            if(width < 1024 || 'ontouchstart' in window) document.getElementById('mobile-controls').style.display = 'block';
            else document.getElementById('mobile-controls').style.display = 'none';
        }
        window.addEventListener('resize', resize); resize(); loadData();

        // --- INPUT ---
        function handleDirectionInput(dir) {
            if(isPaused) return; 
            if(savedData.hasDash) {
                const now = Date.now();
                if(lastTapKey === dir && (now - lastTapTime) < 300) {
                    player.vx = (dir === 'right') ? DASH_FORCE : -DASH_FORCE; playSound('jump'); 
                }
                lastTapKey = dir; lastTapTime = now;
            }
            if(dir === 'left') keys.left = true;
            if(dir === 'right') keys.right = true;
        }

        window.addEventListener('keydown', e => {
            if(isPaused) return;
            const k = savedData.settings.keys;
            if(e.code === k.left) handleDirectionInput('left');
            if(e.code === k.right) handleDirectionInput('right');
            if(k.jump.includes(e.code)) jump();
            if(e.code === k.hook) fireHook();
            if(e.code === 'Escape') pauseGame(); 
        });
        window.addEventListener('keyup', e => {
            const k = savedData.settings.keys;
            if(e.code === k.left) keys.left = false;
            if(e.code === k.right) keys.right = false;
            if(e.code === k.hook) releaseHook();
        });
        
        const bindTouch = (id, actionDown, actionUp) => {
            const btn = document.getElementById(id);
            btn.addEventListener('pointerdown', (e)=>{ if(isPaused)return; e.preventDefault(); actionDown(); btn.style.borderColor='#f1c40f'; btn.style.transform = 'scale(0.95)'; });
            const stop = (e) => { e.preventDefault(); if(actionUp) actionUp(); btn.style.borderColor='rgba(255,255,255,0.4)'; btn.style.transform = 'scale(1)'; };
            btn.addEventListener('pointerup', stop); btn.addEventListener('pointerleave', stop);
        };
        bindTouch('btn-left', ()=>handleDirectionInput('left'), ()=>keys.left=false);
        bindTouch('btn-right', ()=>handleDirectionInput('right'), ()=>keys.right=false);
        bindTouch('btn-jump', ()=>jump(), null);
        bindTouch('btn-hook', ()=>fireHook(), ()=>releaseHook());

        function startGame() { 
            playSound('start'); 
            document.getElementById('main-menu').style.display = 'none'; 
            document.getElementById('hud').style.display = 'block'; 
            resetGame(); 
        }

        function pauseGame() {
            if(!isRunning || isPaused) return;
            isPaused = true;
            document.getElementById('pause-menu').style.display = 'flex';
            document.getElementById('pause-btn').style.display = 'none';
        }

        function resumeGame() {
            if(!isPaused) return;
            isPaused = false;
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('pause-btn').style.display = 'block';
            loop(); 
        }

        function quitToMenu() {
            isRunning = false; isPaused = false;
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('pause-btn').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            audio.music.pause();
        }

        function resetGame() {
            isRunning = true; isPaused = false;
            player.x = 100; player.y = 100; player.vx = 0; player.vy = 0;
            player.hook.state = 'idle'; player.jumpCount = 0;
            camera.x = 0; score = 0; collectedCoins = 0;
            startTime = Date.now(); elapsedTime = 0;
            
            reviveCost = 10; revivesUsed = 0;
            platforms = [{x: 0, y: height - 100, w: 1000, h: 100}];
            coins = []; traps = []; enemies = []; powerupItems = [];
            
            // Clear Active Effects
            activeEffects.magnet = 0;
            activeEffects.shield = false;
            activeEffects.doubleScore = 0;
            activeEffects.reviveShieldTimer = 0;

            document.getElementById('game-over').style.display = 'none';
            document.getElementById('pause-btn').style.display = 'block';
            playSound('music'); loop();
        }

        function jump() {
            if(player.grounded) { player.vy = JUMP_FORCE; player.grounded = false; player.jumpCount = 1; playSound('jump'); }
            else if(savedData.hasDoubleJump && player.jumpCount < 2) { player.vy = JUMP_FORCE; player.jumpCount++; playSound('jump'); }
        }

        function fireHook() {
            if(player.hook.state !== 'idle') return;
            let bestDist = Infinity; let target = null;
            const px = player.x + player.w/2; const py = player.y + player.h/2;
            const perfLimit = savedData.settings.perf === 0 ? 10 : 20; 
            if(platforms.length > perfLimit) platforms = platforms.slice(-perfLimit);

            for(let p of platforms) {
                if(p.x + p.w < camera.x) continue;
                const cx = p.x + p.w/2; const cy = p.y + p.h/2;
                let dist = Math.hypot(cx - px, cy - py);
                if(cy < py) dist *= 0.7;
                if(dist < 750 && dist < bestDist && cx > px - 50) { bestDist = dist; target = {x: cx, y: cy}; }
            }
            if(target) {
                currentTarget = target; player.hook.state = 'shooting';
                player.hook.x = px; player.hook.y = py;
                const dx = target.x - px; const dy = target.y - py;
                const len = Math.sqrt(dx*dx+dy*dy);
                player.hook.vx = (dx/len)*HOOK_SPEED; player.hook.vy = (dy/len)*HOOK_SPEED;
                playSound('hook');
            }
        }
        function releaseHook() {
            if(player.hook.state === 'pulling') { player.vy = -6; player.vx *= 1.2; player.jumpCount = 1; }
            player.hook.state = 'idle';
        }

        function generateLevel() {
            const lastP = platforms[platforms.length - 1];
            let startX = lastP ? lastP.x + lastP.w : 0;
            const genLimit = savedData.settings.perf === 0 ? 1000 : 1500;

            while(startX < camera.x + width + genLimit) {
                let diff = Math.min(score / 2000, 1.0); 
                let minGap = 120 + (diff * 100); let maxGap = 250 + (diff * 200); if(maxGap > 500) maxGap = 500;
                const gap = minGap + Math.random() * (maxGap - minGap);
                const w = Math.max(150, 200 + Math.random() * (400 - diff * 150));
                let y = height - 120 - Math.random() * 250;
                if(y > height - 100) y = height - 120;
                
                const p = {x: startX + gap, y: y, w: w, h: 50};
                platforms.push(p);

                // Enemies
                if(w > 250 && Math.random() < 0.35) {
                    const eW = 100; const eH = 100;
                    enemies.push({
                        x: p.x + 50 + Math.random() * (p.w - 100),
                        y: p.y - eH, w: eW, h: eH,
                        vx: ENEMY_SPEED_PATROL, vy: 0,
                        platformRef: p, facingRight: true, state: 'patrol'
                    });
                } else {
                    // Traps
                    if(Math.random() < 0.3 + (diff*0.6)) {
                        const tW = 60; const tH = 40;
                        const tX = p.x + 30 + Math.random() * (p.w - 90);
                        traps.push({x: tX, y: p.y - tH, w: tW, h: tH, startY: p.y - tH, moving: Math.random()>0.5, speed: 0.05+Math.random()*0.05, range: 50+Math.random()*80, offset: Math.random()*10});
                    }
                }

                // Coins
                if(Math.random() > 0.4) {
                    let isMega = false;
                    if(normalCoinsSpawned >= coinsToNextMega) {
                        isMega = true; normalCoinsSpawned = 0; coinsToNextMega = 10 + Math.floor(Math.random() * 6);
                    } else normalCoinsSpawned++;
                    let size = isMega ? 90 : 50; let val = isMega ? 5 : 1;
                    coins.push({ x: p.x + p.w/2 - size/2, y: p.y - 100 - Math.random()*100, w: size, h: size, collected: false, value: val, isMega: isMega });
                }

                // Powerups (5% chance)
                if(Math.random() < 0.05) {
                    const typeRoll = Math.random();
                    let type = 'magnet';
                    if(typeRoll > 0.33) type = 'shield';
                    if(typeRoll > 0.66) type = 'doubleScore';
                    
                    powerupItems.push({
                        x: p.x + p.w/2,
                        y: p.y - 150,
                        w: 50, h: 50,
                        type: type,
                        collected: false
                    });
                }

                startX += gap + w;
            }
            const cleanupDist = savedData.settings.perf === 0 ? 1200 : 1500;
            if(platforms.length > 20) platforms.shift();
            coins = coins.filter(c => c.x > camera.x - cleanupDist);
            traps = traps.filter(t => t.x > camera.x - cleanupDist);
            enemies = enemies.filter(e => e.x > camera.x - cleanupDist && e.y < height + 500);
            powerupItems = powerupItems.filter(p => p.x > camera.x - cleanupDist);
        }

        function loop() {
            if(!isRunning) return;
            if(isPaused) return; 

            gameTick++; elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('time-display').innerText = formatTime(elapsedTime);

            // Update Active Effects
            if(activeEffects.magnet > 0) activeEffects.magnet--;
            if(activeEffects.doubleScore > 0) activeEffects.doubleScore--;
            if(activeEffects.reviveShieldTimer > 0) activeEffects.reviveShieldTimer--;

            // UI Status Update
            let statusText = "";
            if(activeEffects.shield || activeEffects.reviveShieldTimer > 0) statusText += "üõ°Ô∏è ";
            if(activeEffects.magnet > 0) statusText += "üß≤ " + Math.ceil(activeEffects.magnet/60);
            if(activeEffects.doubleScore > 0) statusText += " ‚≠ê " + Math.ceil(activeEffects.doubleScore/60);
            document.getElementById('powerup-status').innerText = statusText;

            const allowAnim = savedData.settings.perf > 0;

            traps.forEach(t => { 
                if(t.moving && allowAnim) t.y = t.startY - ((Math.sin(gameTick*t.speed + t.offset)+1)/2 * t.range); 
            });

            enemies.forEach(e => {
                e.vy += GRAVITY; e.y += e.vy;
                let onGround = false;
                if(e.y + e.h >= e.platformRef.y && e.y + e.h <= e.platformRef.y + 50) {
                    if(e.x + e.w > e.platformRef.x && e.x < e.platformRef.x + e.platformRef.w) {
                        onGround = true; e.y = e.platformRef.y - e.h + 15; e.vy = 0;
                    }
                }
                if(onGround) {
                    const distToPlayer = Math.sqrt(Math.pow(player.x - e.x, 2) + Math.pow(player.y - e.y, 2));
                    if(distToPlayer < ENEMY_VISION && Math.abs(player.y - e.y) < 150) e.state = 'chase';
                    else e.state = 'patrol';

                    if(e.state === 'chase') {
                        if(player.x > e.x) { e.vx = ENEMY_SPEED_CHASE; e.facingRight = true; } else { e.vx = -ENEMY_SPEED_CHASE; e.facingRight = false; }
                    } else {
                        if(e.x < e.platformRef.x) { e.vx = ENEMY_SPEED_PATROL; e.facingRight = true; }
                        if(e.x + e.w > e.platformRef.x + e.platformRef.w) { e.vx = -ENEMY_SPEED_PATROL; e.facingRight = false; }
                    }
                    e.x += e.vx;
                } else { e.x += e.vx * 0.5; }

                // -- ENEMY COLLISION --
                const pad = 20;
                if(player.x + pad < e.x + e.w - pad && player.x + player.w - pad > e.x + pad &&
                   player.y + player.h > e.y + pad && player.y < e.y + e.h - pad) {
                    
                    if(activeEffects.shield || activeEffects.reviveShieldTimer > 0) {
                        e.destroyed = true; // Mark enemy for deletion
                        playSound('coin'); 
                        player.vy = -8; 
                        // Only break normal shield if not in revive mode
                        if(activeEffects.shield && activeEffects.reviveShieldTimer <= 0) {
                            activeEffects.shield = false;
                        }
                    } else {
                        die();
                    }
                }
            });
            // Filter dead enemies
            enemies = enemies.filter(e => !e.destroyed);

            if(keys.left) { player.vx -= MOVE_SPEED; player.facingRight = false; }
            if(keys.right) { player.vx += MOVE_SPEED; player.facingRight = true; }
            player.vy += GRAVITY; player.vx *= FRICTION;
            
            let maxS = 16; if(savedData.hasDash && Math.abs(player.vx) > 16) maxS = DASH_FORCE; 
            if(player.vx > maxS) player.vx = maxS; if(player.vx < -maxS) player.vx = -maxS;

            if(player.hook.state === 'shooting') {
                player.hook.x += player.hook.vx; player.hook.y += player.hook.vy;
                if(Math.hypot(player.hook.x - currentTarget.x, player.hook.y - currentTarget.y) < HOOK_SPEED) {
                    player.hook.state = 'pulling'; player.hook.targetX = currentTarget.x; player.hook.targetY = currentTarget.y;
                }
                if(Math.hypot(player.hook.x - player.x, player.hook.y - player.y) > 850) player.hook.state = 'idle';
            } else if (player.hook.state === 'pulling') {
                const dx = player.hook.targetX - (player.x + player.w/2); const dy = player.hook.targetY - (player.y + player.h/2);
                const angle = Math.atan2(dy, dx);
                player.vx += Math.cos(angle) * HOOK_PULL; player.vy += Math.sin(angle) * HOOK_PULL;
                if(Math.hypot(dx, dy) < 40) player.hook.state = 'idle';
            }

            player.x += player.vx; player.y += player.vy;
            player.grounded = false;
            for(let p of platforms) {
                if(player.vy >= 0 && player.x + player.w > p.x + 10 && player.x < p.x + p.w - 10 &&
                   player.y + player.h >= p.y && player.y + player.h <= p.y + 45) {
                    player.y = p.y - player.h; player.vy = 0; player.grounded = true; player.jumpCount = 0; 
                }
            }

            // Powerup Collision
            powerupItems.forEach(p => {
                if(!p.collected && 
                   player.x < p.x+p.w && player.x+player.w > p.x &&
                   player.y < p.y+p.h && player.y+player.h > p.y) {
                    p.collected = true;
                    playSound('coin'); 
                    if(p.type === 'magnet') activeEffects.magnet = 600; // 10 sec
                    if(p.type === 'shield') activeEffects.shield = true;
                    if(p.type === 'doubleScore') activeEffects.doubleScore = 600; // 10 sec
                }
            });

            coins.forEach(c => {
                if(c.collected) return;
                
                // Magnet Logic
                if(activeEffects.magnet > 0) {
                    const dist = Math.hypot(player.x - c.x, player.y - c.y);
                    if(dist < 400) {
                        c.x += (player.x - c.x) * 0.15;
                        c.y += (player.y - c.y) * 0.15;
                    }
                }

                if(player.x < c.x+c.w && player.x+player.w > c.x && player.y < c.y+c.h && player.y+player.h > c.y) {
                    c.collected = true; 
                    let val = c.value;
                    if(activeEffects.doubleScore > 0) val *= 2;
                    collectedCoins += val; 
                    playSound('coin');
                    if(savedData.settings.vib && navigator.vibrate) navigator.vibrate(30);
                }
            });

            // -- TRAP COLLISION --
            traps.forEach(t => {
                const pad = 12;
                if(player.x+pad < t.x+t.w-pad && player.x+player.w-pad > t.x+pad && player.y+player.h > t.y+15 && player.y < t.y+t.h) {
                    if(activeEffects.shield || activeEffects.reviveShieldTimer > 0) {
                        t.destroyed = true; // Mark trap destroyed
                        playSound('coin');
                        player.vy = -8;
                        if(activeEffects.shield && activeEffects.reviveShieldTimer <= 0) {
                            activeEffects.shield = false;
                        }
                    } else {
                        die();
                    }
                }
            });
            // Filter destroyed traps
            traps = traps.filter(t => !t.destroyed);

            if(player.y > height + 200) die();

            let targetCam = player.x - width / 3; if(targetCam < 0) targetCam = 0;
            camera.x += (targetCam - camera.x) * 0.2;
            if(player.x > score) score = Math.floor(player.x / 10);
            
            document.getElementById('score').innerText = score;
            document.getElementById('coin-count').innerText = collectedCoins;
            generateLevel(); draw(); requestAnimationFrame(loop);
        }

        function die() {
            if(!isRunning) return; isRunning = false;
            audio.music.pause(); playSound('die');
            if(savedData.settings.vib && navigator.vibrate) navigator.vibrate(200);

            const runData = { score: score, time: elapsedTime, coins: collectedCoins };
            savedData.lastRun = runData;
            savedData.history.push(runData);
            savedData.history.sort((a,b) => b.score - a.score);
            if(savedData.history.length > 5) savedData.history = savedData.history.slice(0, 5);

            savedData.totalCoins += collectedCoins;
            if(score > savedData.highScore) {
                savedData.highScore = score;
                savedData.bestTime = elapsedTime; 
            }
            saveDataToStorage();

            document.getElementById('final-score').innerText = score;
            document.getElementById('final-coins').innerText = collectedCoins;
            document.getElementById('pause-btn').style.display = 'none'; 
            
            const btnRevive = document.getElementById('btn-revive');
            if(revivesUsed < 3 && savedData.totalCoins >= reviveCost) {
                btnRevive.style.display = 'inline-block';
                document.getElementById('revive-cost').innerText = reviveCost;
            } else {
                btnRevive.style.display = 'none';
            }

            document.getElementById('game-over').style.display = 'flex';
        }

        function revivePlayer() {
            if(savedData.totalCoins >= reviveCost) {
                savedData.totalCoins -= reviveCost;
                reviveCost += 5; 
                revivesUsed++;
                saveDataToStorage();

                // 1. Find Safe Platform (Nearest behind or around)
                let safePlat = null;
                let minDist = Infinity;
                for(let p of platforms) {
                    if (p.x < player.x + 300 && p.x + p.w > camera.x) { 
                        const dist = Math.abs(p.x - player.x);
                        if(dist < minDist) { minDist = dist; safePlat = p; }
                    }
                }

                if(safePlat) {
                    player.x = safePlat.x + Math.min(50, safePlat.w/2); 
                    player.y = safePlat.y - player.h - 10;
                } else {
                    player.y = 200; 
                }

                player.vy = 0; player.vx = 0;
                
                // Clear threats nearby
                const clearRadius = 600;
                traps = traps.filter(t => Math.hypot(t.x - player.x, t.y - player.y) > clearRadius);
                enemies = enemies.filter(e => Math.hypot(e.x - player.x, e.y - player.y) > clearRadius);

                activeEffects.reviveShieldTimer = 180; // 3 Seconds Invincibility
                isRunning = true;
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('pause-btn').style.display = 'block'; 
                audio.music.play();
                loop();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            ctx.save();
            const perf = savedData.settings.perf; 
            if(perf === 0) {
                if(assets.bgLow.complete) {
                     ctx.drawImage(assets.bgLow, 0, 0, width, height);
                } else {
                    ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,width,height);
                }
            } else {
                if(assets.bg.complete) {
                    let bx = -(camera.x * 0.15) % width; if(bx > 0) bx -= width;
                    ctx.drawImage(assets.bg, bx, 0, width, height); ctx.drawImage(assets.bg, bx+width, 0, width, height);
                } else { ctx.fillStyle = '#202028'; ctx.fillRect(0,0,width,height); }
            }
            ctx.restore();

            ctx.save(); ctx.translate(-camera.x, 0);

            platforms.forEach(p => {
                if(assets.ground.complete) {
                    let pat = ctx.createPattern(assets.ground, 'repeat');
                    ctx.fillStyle = pat; ctx.save(); ctx.translate(p.x, p.y); ctx.fillRect(0,0,p.w,p.h); ctx.restore();
                    ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillRect(p.x, p.y, p.w, 4);
                } else { ctx.fillStyle = '#7f8c8d'; ctx.fillRect(p.x, p.y, p.w, p.h); }
            });

            traps.forEach(t => {
                if(assets.spike.complete) ctx.drawImage(assets.spike, t.x, t.y, t.w, t.h);
                else { ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.moveTo(t.x, t.y+t.h); ctx.lineTo(t.x+t.w/2, t.y); ctx.lineTo(t.x+t.w, t.y+t.h); ctx.fill(); }
            });

            enemies.forEach(e => {
                const bounce = perf === 2 ? Math.sin(gameTick * 0.2) * 3 : 0; 
                const ey = e.y + bounce;
                ctx.save();
                ctx.translate(e.x + e.w/2, ey + e.h/2);
                ctx.scale(e.facingRight ? 1 : -1, 1);
                if(assets.enemy.complete) ctx.drawImage(assets.enemy, -e.w/2, -e.h/2, e.w, e.h);
                else { ctx.fillStyle = '#9b59b6'; ctx.fillRect(-e.w/2, -e.h/2, e.w, e.h); }
                ctx.restore();
                if(e.state === 'chase') {
                    const iconX = e.x + e.w/2 - 5; const iconY = ey - 40;
                    ctx.fillStyle = '#FFFFFF'; ctx.fillRect(iconX - 2, iconY - 2, 14, 44);
                    ctx.fillStyle = '#e74c3c'; ctx.fillRect(iconX, iconY, 10, 25); ctx.fillRect(iconX, iconY + 30, 10, 10);
                }
            });

            coins.forEach(c => {
                if(c.collected) return;
                const bob = perf === 2 ? Math.sin(gameTick * 0.1) * 5 : 0;
                if(assets.coin.complete) ctx.drawImage(assets.coin, c.x, c.y + bob, c.w, c.h);
                else { ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(c.x+c.w/2, c.y+c.h/2+bob, c.w/2, 0, Math.PI*2); ctx.fill(); }
            });

            // Draw Powerup Items
            powerupItems.forEach(p => {
                if(p.collected) return;
                const bob = Math.sin(gameTick * 0.1) * 5;
                let img = null;
                if(p.type === 'magnet') img = assets.magnet;
                else if(p.type === 'shield') img = assets.shield;
                else if(p.type === 'doubleScore') img = assets.star;

                if(img && img.complete) ctx.drawImage(img, p.x, p.y + bob, p.w, p.h);
                else { 
                    ctx.fillStyle = p.type==='magnet'?'#3498db':p.type==='shield'?'#2ecc71':'#e74c3c'; 
                    ctx.fillRect(p.x, p.y+bob, p.w, p.h); 
                }
            });

            if(player.hook.state !== 'idle') {
                const sx = player.x + player.w/2; const sy = player.y + player.h/2;
                const ex = player.hook.state==='shooting'?player.hook.x:player.hook.targetX;
                const ey = player.hook.state==='shooting'?player.hook.y:player.hook.targetY;
                const dist = Math.hypot(ex-sx, ey-sy); const steps = perf === 0 ? 5 : dist/15;
                ctx.fillStyle = '#bdc3c7';
                for(let i=0; i<steps; i++) {
                    const xx = sx + (ex-sx)*(i/steps); const yy = sy + (ey-sy)*(i/steps);
                    ctx.fillRect(xx-3, yy-3, 6, 6);
                }
                ctx.fillStyle = '#e74c3c'; ctx.fillRect(ex-5, ey-5, 10, 10);
            }

            let animY = 0; let scaleY = 1;
            if(perf === 2) { 
                if(player.grounded) {
                    if(Math.abs(player.vx)>0.5) animY = Math.sin(gameTick*0.5)*3; 
                    else scaleY = 1 + Math.sin(gameTick*0.1)*0.03; 
                } else scaleY = 1.1;
            }

            ctx.save();
            const cx = player.x + player.w/2; const cy = player.y + player.h/2 + animY;
            
            // --- PIXEL SHIELD EFFECT ---
            if(activeEffects.shield || activeEffects.reviveShieldTimer > 0) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(gameTick * 0.05); // Spin
                
                // Outer Hexagon-ish Shape
                ctx.strokeStyle = '#2ecc71'; 
                ctx.lineWidth = 4;
                ctx.strokeRect(-50, -50, 100, 100); 

                // Inner Pulse
                const pulse = Math.sin(gameTick * 0.2) * 5;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.strokeRect(-(40+pulse), -(40+pulse), (40+pulse)*2, (40+pulse)*2);
                
                ctx.restore();
            }

            ctx.translate(cx, cy); ctx.scale(player.facingRight?1:-1, scaleY);
            if(assets.player.complete) ctx.drawImage(assets.player, -player.w/2, -player.h/2, player.w, player.h);
            else { ctx.fillStyle='#3498db'; ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h); }
            ctx.restore();

            ctx.restore();
        }
    </script>
</body>
</html>